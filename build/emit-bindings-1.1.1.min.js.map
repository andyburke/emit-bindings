{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/eventemitter2/lib/eventemitter2.js","index.js"],"names":[],"mappings":"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","file":"emit-bindings-1.1.1.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*!\n * EventEmitter2\n * https://github.com/hij1nx/EventEmitter2\n *\n * Copyright (c) 2013 hij1nx\n * Licensed under the MIT license.\n */\n;!function(undefined) {\n\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n\n  function init() {\n    this._events = {};\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n\n  function configure(conf) {\n    if (conf) {\n\n      this._conf = conf;\n\n      conf.delimiter && (this.delimiter = conf.delimiter);\n      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this.newListener = conf.newListener);\n\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n\n  function EventEmitter(conf) {\n    this._events = {};\n    this.newListener = false;\n    configure.call(this, conf);\n  }\n\n  //\n  // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n  function searchListenerTree(handlers, type, tree, i) {\n    if (!tree) {\n      return [];\n    }\n    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,\n        typeLength = type.length, currentType = type[i], nextType = type[i+1];\n    if (i === typeLength && tree._listeners) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n      if (typeof tree._listeners === 'function') {\n        handlers && handlers.push(tree._listeners);\n        return [tree];\n      } else {\n        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {\n          handlers && handlers.push(tree._listeners[leaf]);\n        }\n        return [tree];\n      }\n    }\n\n    if ((currentType === '*' || currentType === '**') || tree[currentType]) {\n      //\n      // If the event emitted is '*' at this part\n      // or there is a concrete match at this patch\n      //\n      if (currentType === '*') {\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));\n          }\n        }\n        return listeners;\n      } else if(currentType === '**') {\n        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));\n        if(endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));\n        }\n\n        for (branch in tree) {\n          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {\n            if(branch === '*' || branch === '**') {\n              if(tree[branch]._listeners && !endReached) {\n                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));\n              }\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            } else if(branch === nextType) {\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));\n            }\n          }\n        }\n        return listeners;\n      }\n\n      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));\n    }\n\n    xTree = tree['*'];\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i+1);\n    }\n\n    xxTree = tree['**'];\n    if(xxTree) {\n      if(i < typeLength) {\n        if(xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength);\n        }\n\n        // Build arrays of matching next branches and others.\n        for(branch in xxTree) {\n          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {\n            if(branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i+2);\n            } else if(branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i+1);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);\n            }\n          }\n        }\n      } else if(xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength);\n      } else if(xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength);\n      }\n    }\n\n    return listeners;\n  }\n\n  function growListenerTree(type, listener) {\n\n    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n\n    //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n    for(var i = 0, len = type.length; i+1 < len; i++) {\n      if(type[i] === '**' && type[i+1] === '**') {\n        return;\n      }\n    }\n\n    var tree = this.listenerTree;\n    var name = type.shift();\n\n    while (name) {\n\n      if (!tree[name]) {\n        tree[name] = {};\n      }\n\n      tree = tree[name];\n\n      if (type.length === 0) {\n\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        }\n        else if(typeof tree._listeners === 'function') {\n          tree._listeners = [tree._listeners, listener];\n        }\n        else if (isArray(tree._listeners)) {\n\n          tree._listeners.push(listener);\n\n          if (!tree._listeners.warned) {\n\n            var m = defaultMaxListeners;\n\n            if (typeof this._events.maxListeners !== 'undefined') {\n              m = this._events.maxListeners;\n            }\n\n            if (m > 0 && tree._listeners.length > m) {\n\n              tree._listeners.warned = true;\n              console.error('(node) warning: possible EventEmitter memory ' +\n                            'leak detected. %d listeners added. ' +\n                            'Use emitter.setMaxListeners() to increase limit.',\n                            tree._listeners.length);\n              console.trace();\n            }\n          }\n        }\n        return true;\n      }\n      name = type.shift();\n    }\n    return true;\n  }\n\n  // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n  EventEmitter.prototype.delimiter = '.';\n\n  EventEmitter.prototype.setMaxListeners = function(n) {\n    this._events || init.call(this);\n    this._events.maxListeners = n;\n    if (!this._conf) this._conf = {};\n    this._conf.maxListeners = n;\n  };\n\n  EventEmitter.prototype.event = '';\n\n  EventEmitter.prototype.once = function(event, fn) {\n    this.many(event, 1, fn);\n    return this;\n  };\n\n  EventEmitter.prototype.many = function(event, ttl, fn) {\n    var self = this;\n\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n      fn.apply(this, arguments);\n    }\n\n    listener._origin = fn;\n\n    this.on(event, listener);\n\n    return self;\n  };\n\n  EventEmitter.prototype.emit = function() {\n\n    this._events || init.call(this);\n\n    var type = arguments[0];\n\n    if (type === 'newListener' && !this.newListener) {\n      if (!this._events.newListener) { return false; }\n    }\n\n    // Loop through the *_all* functions and invoke them.\n    if (this._all) {\n      var l = arguments.length;\n      var args = new Array(l - 1);\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n        this._all[i].apply(this, args);\n      }\n    }\n\n    // If there is no 'error' event listener then throw.\n    if (type === 'error') {\n\n      if (!this._all &&\n        !this._events.error &&\n        !(this.wildcard && this.listenerTree.error)) {\n\n        if (arguments[1] instanceof Error) {\n          throw arguments[1]; // Unhandled 'error' event\n        } else {\n          throw new Error(\"Uncaught, unspecified 'error' event.\");\n        }\n        return false;\n      }\n    }\n\n    var handler;\n\n    if(this.wildcard) {\n      handler = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    }\n    else {\n      handler = this._events[type];\n    }\n\n    if (typeof handler === 'function') {\n      this.event = type;\n      if (arguments.length === 1) {\n        handler.call(this);\n      }\n      else if (arguments.length > 1)\n        switch (arguments.length) {\n          case 2:\n            handler.call(this, arguments[1]);\n            break;\n          case 3:\n            handler.call(this, arguments[1], arguments[2]);\n            break;\n          // slower\n          default:\n            var l = arguments.length;\n            var args = new Array(l - 1);\n            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n            handler.apply(this, args);\n        }\n      return true;\n    }\n    else if (handler) {\n      var l = arguments.length;\n      var args = new Array(l - 1);\n      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];\n\n      var listeners = handler.slice();\n      for (var i = 0, l = listeners.length; i < l; i++) {\n        this.event = type;\n        listeners[i].apply(this, args);\n      }\n      return (listeners.length > 0) || !!this._all;\n    }\n    else {\n      return !!this._all;\n    }\n\n  };\n\n  EventEmitter.prototype.on = function(type, listener) {\n\n    if (typeof type === 'function') {\n      this.onAny(type);\n      return this;\n    }\n\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n    this._events || init.call(this);\n\n    // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n    this.emit('newListener', type, listener);\n\n    if(this.wildcard) {\n      growListenerTree.call(this, type, listener);\n      return this;\n    }\n\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    }\n    else if(typeof this._events[type] === 'function') {\n      // Adding the second element, need to change to array.\n      this._events[type] = [this._events[type], listener];\n    }\n    else if (isArray(this._events[type])) {\n      // If we've already got an array, just append.\n      this._events[type].push(listener);\n\n      // Check for listener leak\n      if (!this._events[type].warned) {\n\n        var m = defaultMaxListeners;\n\n        if (typeof this._events.maxListeners !== 'undefined') {\n          m = this._events.maxListeners;\n        }\n\n        if (m > 0 && this._events[type].length > m) {\n\n          this._events[type].warned = true;\n          console.error('(node) warning: possible EventEmitter memory ' +\n                        'leak detected. %d listeners added. ' +\n                        'Use emitter.setMaxListeners() to increase limit.',\n                        this._events[type].length);\n          console.trace();\n        }\n      }\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.onAny = function(fn) {\n\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n\n    if(!this._all) {\n      this._all = [];\n    }\n\n    // Add the function to the event listener collection.\n    this._all.push(fn);\n    return this;\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  EventEmitter.prototype.off = function(type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n\n    var handlers,leafs=[];\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n    }\n    else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({_listeners:handlers});\n    }\n\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n      if (isArray(handlers)) {\n\n        var position = -1;\n\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener ||\n            (handlers[i].listener && handlers[i].listener === listener) ||\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0) {\n          continue;\n        }\n\n        if(this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        }\n        else {\n          this._events[type].splice(position, 1);\n        }\n\n        if (handlers.length === 0) {\n          if(this.wildcard) {\n            delete leaf._listeners;\n          }\n          else {\n            delete this._events[type];\n          }\n        }\n        return this;\n      }\n      else if (handlers === listener ||\n        (handlers.listener && handlers.listener === listener) ||\n        (handlers._origin && handlers._origin === listener)) {\n        if(this.wildcard) {\n          delete leaf._listeners;\n        }\n        else {\n          delete this._events[type];\n        }\n      }\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype.offAny = function(fn) {\n    var i = 0, l = 0, fns;\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n      for(i = 0, l = fns.length; i < l; i++) {\n        if(fn === fns[i]) {\n          fns.splice(i, 1);\n          return this;\n        }\n      }\n    } else {\n      this._all = [];\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\n  EventEmitter.prototype.removeAllListeners = function(type) {\n    if (arguments.length === 0) {\n      !this._events || init.call(this);\n      return this;\n    }\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n\n      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n        var leaf = leafs[iLeaf];\n        leaf._listeners = null;\n      }\n    }\n    else {\n      if (!this._events[type]) return this;\n      this._events[type] = null;\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.listeners = function(type) {\n    if(this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers;\n    }\n\n    this._events || init.call(this);\n\n    if (!this._events[type]) this._events[type] = [];\n    if (!isArray(this._events[type])) {\n      this._events[type] = [this._events[type]];\n    }\n    return this._events[type];\n  };\n\n  EventEmitter.prototype.listenersAny = function() {\n\n    if(this._all) {\n      return this._all;\n    }\n    else {\n      return [];\n    }\n\n  };\n\n  if (typeof define === 'function' && define.amd) {\n     // AMD. Register as an anonymous module.\n    define(function() {\n      return EventEmitter;\n    });\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    exports.EventEmitter2 = EventEmitter;\n  }\n  else {\n    // Browser global.\n    window.EventEmitter2 = EventEmitter;\n  }\n}();\n","'use strict';\n\nvar EventEmitter2 = require( 'eventemitter2' ).EventEmitter2;\n\n/*\n    dependencies\n*/\n\n/* binding */\nvar bindingMethod = window.addEventListener ? 'addEventListener' : 'attachEvent';\nvar eventPrefix = bindingMethod !== 'addEventListener' ? 'on' : '';\n\nfunction bind( el, type, fn, capture ) {\n    el[ bindingMethod ]( eventPrefix + type, fn, capture || false );\n    return fn;\n}\n\n/* matching */\nvar vendorMatch = Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector;\n\nfunction matches( el, selector ) {\n    if ( !el || el.nodeType !== 1 ) {\n        return false;\n    }\n    if ( vendorMatch ) {\n        return vendorMatch.call( el, selector );\n    }\n    var nodes = document.querySelectorAll( selector, el.parentNode );\n    for ( var i = 0; i < nodes.length; ++i ) {\n        if ( nodes[ i ] == el ) {\n            return true;  \n        } \n    }\n    return false;\n}\n\n/* closest */\n\nfunction closest( element, selector, checkSelf, root ) {\n    element = checkSelf ? {parentNode: element} : element;\n\n    root = root || document;\n\n    /* Make sure `element !== document` and `element != null`\n       otherwise we get an illegal invocation */\n    while ( ( element = element.parentNode ) && element !== document ) {\n        if ( matches( element, selector ) ) {\n            return element;\n        }\n\n        /* After `matches` on the edge case that\n           the selector matches the root\n           (when the root is not the document) */\n        if (element === root) {\n            return;\n        }\n    }\n}\n\n/*\n    end dependencies\n*/\n\nfunction Emit() {\n    var self = this;\n    EventEmitter2.call( self );\n\n    self.validators = [];\n    self.touchMoveDelta = 10;\n    self.initialTouchPoint = null;\n\n    bind( document, 'touchstart', self.handleEvent.bind( self ) );\n    bind( document, 'touchmove', self.handleEvent.bind( self ) );\n    bind( document, 'touchend', self.handleEvent.bind( self ) );\n    bind( document, 'click', self.handleEvent.bind( self ) );\n    bind( document, 'input', self.handleEvent.bind( self ) );\n    bind( document, 'submit', self.handleEvent.bind( self ) );\n}\n\nEmit.prototype = Object.create( EventEmitter2.prototype );\n\nfunction getTouchDelta( event, initial ) {\n    var deltaX = ( event.touches[ 0 ].pageX - initial.x );\n    var deltaY = ( event.touches[ 0 ].pageY - initial.y );\n    return Math.sqrt( ( deltaX * deltaX ) + ( deltaY * deltaY ) );\n}\n\nEmit.prototype.handleEvent = function( event ) {\n    var self = this;\n\n    var touches = event.touches;\n    var delta = -1;\n\n    if ( typeof event.propagationStoppedAt !== 'number' || isNaN( event.propagationStoppedAt ) ) {\n        event.propagationStoppedAt = 100; // highest possible value\n    }\n\n    switch ( event.type ) {\n        case 'touchstart':\n            self.initialTouchPoint = self.lastTouchPoint = {\n                x: touches && touches.length ? touches[ 0 ].pageX : 0,\n                y: touches && touches.length ? touches[ 0 ].pageY : 0\n            };\n\n            break;\n\n        case 'touchmove':\n            if ( touches && touches.length && self.initialTouchPoint ) {\n                delta = getTouchDelta( event, self.initialTouchPoint );\n                if ( delta > self.touchMoveDelta ) {\n                    self.initialTouchPoint = null;\n                }\n\n                self.lastTouchPoint = {\n                    x: touches[ 0 ].pageX,\n                    y: touches[ 0 ].pageY\n                };\n            }\n\n            break;\n\n        case 'click':\n        case 'touchend':\n        case 'input':\n        case 'submit':\n            // eat any late-firing click events on touch devices\n            if ( event.type === 'click' && self.lastTouchPoint ) {\n                if ( event.touches && event.touches.length ) {\n                    delta = getTouchDelta( event, self.lastTouchPoint );\n                    if ( delta < self.touchMoveDelta ) {\n                        event.preventDefault();\n                        event.stopPropagation();\n                        return;\n                    }\n                }\n            }\n\n            // handle canceling touches that have moved too much\n            if ( event.type === 'touchend' && !self.initialTouchPoint ) {\n                return;\n            }\n\n            var selector = 'a,button,input,[data-emit]';\n            var originalElement = event.target || event.srcElement;\n            var el = originalElement;\n            \n            var depth = -1;\n            var handled = false;\n            while( el && event.propagationStoppedAt > depth && ++depth < 100 ) {\n                event.emitTarget = el;\n                event.depth = depth;\n                \n                if ( !el.hasAttribute( 'data-emit' ) ) {\n                    // if it's a link, button or input and it has no emit attribute, allow the event to pass\n                    if ( el.tagName === 'A' || el.tagName === 'BUTTON' || el.tagName === 'INPUT' ) {\n                        return;\n                    }\n                    else {\n                        el = closest( el, selector, false, document );\n                        continue;\n                    }\n                }\n\n                var forceAllowDefault = el.tagName == 'INPUT' && ( el.type == 'checkbox' || el.type == 'radio' );\n\n                var validated = true;\n                for ( var validatorIndex = 0; validatorIndex < self.validators.length; ++validatorIndex ) {\n                    if ( !self.validators[ validatorIndex ].call( this, el, event ) ) {\n                        validated = false;\n                        break;\n                    }\n                }\n\n                // eat the event if a validator failed\n                if ( !validated ) {\n                    event.preventDefault();\n                    event.stopPropagation();\n                    event.propagationStoppedAt = depth;\n                    el = null;\n                    continue;\n                }\n                \n                if ( typeof( self.validate ) == 'function' && !self.validate.call( self, el ) ) {\n                    el = closest( el, selector, false, document );\n                    continue;\n                }\n\n                if ( el.tagName == 'FORM' ) {\n                    if ( event.type != 'submit' ) {\n                        el = closest( el, selector, false, document );\n                        continue;\n                    }\n                }\n                else if ( el.tagName == 'INPUT' ) {\n                    if ( !( el.type == 'submit' || el.type == 'checkbox' || el.type == 'radio' || el.type == 'file' ) && event.type != 'input' ) {\n                        el = closest( el, selector, false, document );\n                        continue;\n                    }\n                }\n                else if ( el.tagName == 'SELECT' ) {\n                    if ( event.type != 'input' ) {\n                        el = closest( el, selector, false, document );\n                        continue;\n                    }\n                }\n\n                handled |= self._emit( el, event, forceAllowDefault );\n                el = closest( el, selector, false, document );\n            }\n            \n            if ( !handled ) {\n                self.emit( 'unhandled', event );\n            }\n            else if ( depth >= 100 ) {\n                throw new Error( 'Exceeded depth limit for Emit calls.' );\n            }\n\n            self.initialTouchPoint = null;\n\n            break;\n    }\n};\n\nEmit.prototype._emit = function( element, event, forceDefault ) {\n    var self = this;\n\n    var optionString = element.getAttribute( 'data-emit-options' );\n    var options = {};\n    var ignoreString = element.getAttribute( 'data-emit-ignore' );\n    var i;\n\n    if ( ignoreString && ignoreString.length ) {\n        var ignoredEvents = ignoreString.toLowerCase().split( ' ' );\n        for ( i = 0; i < ignoredEvents.length; ++i ) {\n            if ( event.type == ignoredEvents[ i ] ) {\n                return false;\n            }\n        }\n    }\n\n    if ( optionString && optionString.length ) {\n        var opts = optionString.toLowerCase().split( ' ' );\n        for ( i = 0; i < opts.length; ++i ) {\n            options[ opts[ i ] ] = true;\n        }\n    }\n\n    if ( !forceDefault && !options.allowdefault ) {\n        event.preventDefault();\n    }\n\n    if ( !options.allowpropagate ) {\n        event.stopPropagation();\n        event.propagationStoppedAt = event.depth;\n    }\n\n    var emissionList = element.getAttribute( 'data-emit' );\n    if ( !emissionList ) {\n        // allow for empty behaviors that catch events\n        return true;\n    }\n\n    var emissions = emissionList.split( ',' );\n    if ( options.debounce ) {\n        self.timeouts = self.timeouts || {};\n        if ( self.timeouts[ element ] ) {\n            clearTimeout( self.timeouts[ element ] );\n        }\n        \n        (function() {\n            var _element = element;\n            var _emissions = emissions;\n            var _event = event;\n            self.timeouts[ element ] = setTimeout( function() {\n                _emissions.forEach( function( emission ) {\n                    self.emit( emission, _event );\n                } );\n                clearTimeout( self.timeouts[ _element ] );\n                self.timeouts[ _element ] = null;\n            }, 250 );\n        } )();\n\n        return true;\n    }\n    \n    emissions.forEach( function( emission ) {\n        self.emit( emission, event );\n    } );\n    \n    return true;\n};\n\nEmit.prototype.addValidator = function( validator ) {\n    var self = this;\n\n    var found = false;\n    for ( var i = 0; i < self.validators.length; ++i ) {\n        if ( self.validators[ i ] == validator ) {\n            found = true;\n            break;\n        }\n    }\n\n    if ( found ) {\n        return false;\n    }\n\n    self.validators.push( validator );\n    return true;\n};\n\nEmit.prototype.removeValidator = function( validator ) {\n    var self = this;\n\n    var found = false;\n    for ( var i = 0; i < self.validators.length; ++i ) {\n        if ( self.validators[ i ] == validator ) {\n            self.validators.splice( i, 1 );\n            found = true;\n            break;\n        }\n    }\n\n    return found;\n};\n\nEmit.singleton = Emit.singleton || new Emit();\nEmit.singleton.Emit = Emit;\n\nmodule.exports = Emit.singleton;\n"],"sourceRoot":"/source/"}